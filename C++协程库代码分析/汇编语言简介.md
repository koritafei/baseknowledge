## 汇编语法格式
1. `AT&T`汇编语言中，寄存器前要加`%`作为前缀，`intel`则不需要。
```asm
AT&T 格式           pushl %eax 
Intel格式           push eax
```
2. 在`AT&T`中`$`表示一个立即数，`Intel`中则不是。
```asm
AT&T 格式           pushl $1
Intel格式           push 1
```
3. `AT&T`和`intel`中源操作数和目的操作数正好相反,在`AT&T`汇编中目的操作数在源操作数的右边。
```asm
AT&T 格式           addl $1,%eax
Intel格式           add eax,1
```
4. 在 `AT&T` 汇编中，操作数的字长由操作符的最后一个字母决定，后缀 `'b'、'w'、'l'`分别表示操作数为字节（`byte, 8 bits）、字（word, 16 bits）和长字（long, 32 bits）`；而在 `Intel` 汇编格式中，操作数的字长是用 `"byte ptr" 和 "word ptr"` 等前缀来表示的。
```asm
AT&T 格式           movb val,%al
Intel格式           mov al,byte ptr val
```
5. 在 `AT&T `汇编格式中，绝对转移指令和调用指令`（jump/call）` 的操作数前要加上 `' * '` 作为前缀，`Intel` 格式中不需要。

6. 远转移指令和远程调用指令的操作符，在 `AT&T` 格式中分别为`"ljump"`和`"lcall"`，而在 `Intel` 格式中分别为"jump far"和"call far"。
```asm
                          远转移指令                  远程调用指令
AT&T 格式           ljump $section,$offset     lcall $section,$offset
Intel格式           jump far section:offset    call far section:offset
```
与之对应的远程返回指令为：
```asm
AT&T 格式           lret $stack_adjust
Intel格式           ret far stack_adjust
```
7. 在` AT&T `汇编格式中，内存操作数的寻址方式是：
```asm
section:disp(base, index, scale)
```
在 `Intel` 汇编格式中，内存操作数的寻址方式为：
```asm
section:[base + index*scale + disp]
```
由于 `Linux` 工作在保护模式下，用的是32位线性地址，所以在计算地址是不用考虑段基址和偏移量，而是采用如下的地址计算方法：
```asm
disp + base + index*scale
```
例子如下：
```asm
    AT&T 格式                      Intel格式
movl -4(%ebp),%eax             mov eax,[ebp-4]
movl array(,%eax,4),%eax       mov eax,[eax*4 + array]
movw array(%ebx,%eax,4),%cx    mov cx,[ebx + 4*eax + array]
movb $4,%fs:(%eax)             mov fs:eax,4
```
## `CPU`寄存器作用
### 通用寄存器
首当其冲的是通用寄存器，这些的寄存器是程序执行代码最最常用，也最最基础的寄存器，程序执行过程中，绝大部分时间都是在操作这些寄存器来实现指令功能。

所谓通用，即这些寄存器CPU没有特殊的用途，交给应用程序“随意”使用。对于有些寄存器，CPU有一些潜规则，用的时候要注意。
```
eax: 通常用来执行加法，函数调用的返回值一般也放在这里面
ebx: 数据存取
ecx: 通常用来作为计数器，比如for循环
edx: 读写I/O端口时，edx用来存放端口号
esp: 栈顶指针，指向栈的顶部
ebp: 栈底指针，指向栈的底部，通常用ebp+偏移量的形式来定位函数存放在栈中的局部变量
esi: 字符串操作时，用于存放数据源的地址
edi: 字符串操作时，用于存放目的地址的，和esi两个经常搭配一起使用，执行字符串的复制等操作
```
在x64架构中，上面的通用寄存器都扩展成为64位版本，名字也进行了升级。当然，为了兼容32位模式程序，使用上面的名字仍然是可以访问的，相当于访问64位寄存器的低32位。
```
    rax rbx rcx rdx rsp rbp rsi rdi
```

### 标志寄存器
标志寄存器，里面有众多标记位，记录了CPU执行指令过程中的一系列状态，这些标志大都由CPU自动设置和修改：
```
        CF 进位标志
        PF 奇偶标志
        ZF 零标志
        SF 符号标志
        OF 补码溢出标志
        TF 跟踪标志
        IF 中断标志
        ······
```
![标志寄存器](./images/标志寄存器.png)

### 指令寄存器
eip: 指令寄存器可以说是CPU中最最重要的寄存器了，它指向了下一条要执行的指令所存放的地址，CPU的工作其实就是不断取出它指向的指令，然后执行这条指令，同时指令寄存器继续指向下面一条指令，如此不断重复，这就是CPU工作的基本日常。

### 汇编例子
```asm
# AT&T 格式
# Hello.s
.data #数据段声明
  msg: .string "HELLO WORLD\\N" # 要输出的字符串
  len = . - msg # 字符串长度
.text #代码段声明
.global _start #指定入口函数

_start: #在屏幕上显示一个字符
  movl $len, %edx #参数三字符串长度
  movl $msg, %ecx #要显示的字符串
  movl $1, %ebx #文件描述符
  movl $4, %eax #系统调用号(sys_write)
  int $0x80 #调用内核功能，退出程序

  movl $0, %ebx #参数一: 退出代码
  movl $1, %eax #系统调用号(sys_exit)
  int $0x80 #调用内核功能
```



